{% extends 'base/base.html' %}

{% block content %}
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Anek+Devanagari:wght@100..800&family=Montserrat:ital,wght@0,100..900;1,100..900&family=Roboto+Condensed:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/media/css/mcq_view.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
    
        @keyframes slideIn {
            0% { transform: translateY(-100%); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
        @keyframes fadeOut {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-100%); }
        }
        .notification {
            animation: slideIn 0.5s ease-out, fadeOut 0.5s ease-in forwards 5s;
            z-index: 1000;
        }
        .notification-info {
            background-color: rgba(59, 130, 246, 0.9); /* Blue with slight transparency */
        }
        .notification-success {
            background-color: rgba(16, 185, 129, 0.9); /* Green with slight transparency */
        }
        .notification-error {
            background-color: rgba(239, 68, 68, 0.9); /* Red with slight transparency */
        }
        .notification-warning {
            background-color: rgba(245, 158, 11, 0.9); /* Yellow with slight transparency */
        }
        .score{
            display:none;
        }

</style>
<div id="results-section" style="display:none;">
    <h2>Quiz Results</h2>
    <div class="result-container">
        <div class="result-item">
            <p>Total Questions</p>
            <div class="progress-bar total">
                <span id="total-questions" class="progress-value">0</span>
            </div>
        </div>
        <div class="result-item">
            <p>Correct Answers</p>
            <div class="progress-bar correct">
                <span id="correct-answers" class="progress-value">0</span>
            </div>
        </div>
        <div class="result-item">
            <p>Wrong Answers</p>
            <div class="progress-bar wrong">
                <span id="wrong-answers" class="progress-value">0</span>
            </div>
        </div>
        <div class="result-item">
            <p>Not Attempted</p>
            <div class="progress-bar not-attempted">
                <span id="not-attempt" class="progress-value">0</span>
            </div>
            <button class="review" id="review-result-button">Review</button>
        </div>
    </div>
    <div class="time-taken-container">
        <p>Time Taken: <span id="time-taken"></span></p>
    </div>
</div>
<div class="mcq-container" id="mcq-container">
    <div class="mcq-header">
        <div class="menu-icon" id="menu-icon">‚ò∞</div> <!-- Menu icon -->
        <div class="question-info">
            <div class="review-status" id="review-status"></div>
             <span id="current-question">1</span>  /  <span id="total-questions">{{ count }}</span>
        </div>
        <div class="header-buttons">
            <button class="save" id="save-button">Save</button>
        <button class="review" id="review-button">Review</button>
        <button class="score" id="score-button">Score</button>

            <button class="submit" id="submit-button" style="display:none;">Submit</button>
        </div>
        <div class="timer">Time left: <span id="timer">--</span></div>
    </div>

    <!-- Question Navigation -->
    <div class="question-nav" id="question-nav" style="display:none;">
        <!-- Dynamically generated question numbers will go here -->
    </div>

    <div class="mcq-content">
        <div class="question">
            <p id="question-text"></p>
            <img id="question-image" src="" alt="Question Image">
        </div>

        <ul class="options">
            <!-- Options will be dynamically populated here -->
        </ul>

        <div class="status-text" id="status-text"></div>
        <div id="explanation-container" style="display: none;">
            <textarea id="explanation" readonly></textarea>
          </div>
    </div>

    <div class="mcq-footer">
        <button class="bookmark" id="bookmark-button"><i class="fas fa-bookmark nfas"></i></button>
        <div id="expanded-menu" class="expanded-menu hidden">
            <button class="action-btn1" data-type="Star">‚≠ê Star</button>
            <button class="action-btn1" data-type="Unstudied">üìö Unstudied</button>
            <button class="action-btn1" data-type="Other">üí° Other</button>
        </div>
        <button class="back" id="back-button"><i class="fas fa-arrow-left nfas" ></i> Back</button>
            <button class="next" id="next-button">    Next <i class="fas fa-arrow-right nfas"></i>
        
        
    </div>
</div>

<!-- Fullscreen Image Viewer -->
<div class="image-viewer" id="image-viewer" style="display:none;">
    <img src="" alt="Enlarged Question Image" id="enlarged-image">
</div>
<div class="confirmation-modal" id="confirmation-modal" style="display:none;">
    <div class="modal-content">
        <span class="modal-close" id="modal-close">&times;</span>
        <h2>Confirm Submission</h2>
        <p>Are you sure you want to submit the quiz? You won‚Äôt be able to make changes after submission.</p>
        
        <div class="modal-summary">
            <h3>Unanswered Questions:</h3>
            <ul id="unanswered-list"></ul>
            
            <h3>Questions Under Review:</h3>
            <ul id="review-list"></ul>
        </div>
    </div>
    

    <!-- Buttons Container -->
    <div class="modal-buttons">
        <button id="confirm-submit" class="btan btn-confirm">Confirm</button>
        <button id="cancel-submit" class="btan btn-cancel">Cancel</button>
    </div>
    
</div>
<button id="toggle-draw-btn"><i class="fas fa-pencil-alt nfas"></i></button>
<canvas id="drawingCanvas"></canvas>
<div id="loader" class="loader"></div>

{% if messages %}
        <div class="fixed top-20 left-0 w-full z-9999999">
            {% for message in messages %}
                <div class="notification notification-{{ message.tags }} text-white text-center p-4 shadow-lg">
                    <div class="max-w-xl mx-auto flex items-center justify-center space-x-4">
                        {% if message.tags == 'info' %}
                            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        {% elif message.tags == 'success' %}
                            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        {% elif message.tags == 'warning' %}
                            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                            </svg>
                        {% elif message.tags == 'error' %}
                            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        {% endif %}
                        <span class="text-lg font-semibold">{{ message }}</span>
                    </div>
                </div>
            {% endfor %}
        </div>
    {% endif %}
    <script>
        // Optional: JavaScript to remove messages after animation
        document.addEventListener('DOMContentLoaded', function() {
            const notifications = document.querySelectorAll('.notification');
            notifications.forEach(notification => {
                setTimeout(() => {
                    notification.remove();
                }, 5500); // Slightly longer than CSS animation to ensure removal
            });
        });
    </script>


<script>
    {% if selected_answers %}
        let bookmarkedMcqs = JSON.parse('{{ bookmarked_mcqs|safe }}');
    {% else %}
        let bookmarkedMcqs = {};
    {% endif %}
    const mcqs = JSON.parse('{{ mcqs|escapejs }}'); // Parse the JSON data
    
    let current_que_index =0;
    let currentQuestionIndex = 0;
    {% if selected_answers %}
        let selectedAnswers = JSON.parse('{{ selected_answers|escapejs }}');
        let selectedAnswerTexts = JSON.parse('{{ selected_option_texts|escapejs }}');
        
    {% else %}
        let selectedAnswers = {};
        let selectedAnswerTexts = {};
    {% endif %}
     // Store selected answers by question index
    let reviewQuestions = {}; // Store review status by question index
    let isReviewMode = false;
    console.log(selectedAnswers);
    {% if timespent %}
    let questionTimes = JSON.parse('{{ timespent|escapejs }}');
    console.log("time mila")
    {% else %}
    
    let questionTimes = {};
    {% endif %}
    console.log(selectedAnswerTexts);
    let currentQuestionStartTime = null;
    let currentQuestionUID = null;
    let currentquestionuidforoption =null;
    function loadQuestion(index) {
        if (index < 0 || index >= mcqs.length) return; // Bounds check
        console.log(selectedAnswerTexts);
        
        const mcq = mcqs[index];
        const mcqUid = mcq.uid;
        document.getElementById('question-text').innerText = mcq.text;
        current_que_index = index;
        console.log(mcq);
        if (isReviewMode) {
        document.getElementById('explanation').innerText = mcq.explanation;
        document.getElementById('explanation-container').style.display = 'block';
        
        const textarea = document.getElementById('explanation');
        if (textarea) {
            textarea.style.height = 'auto'; // Reset height
            const scrollHeight = textarea.scrollHeight; // Get the scroll height
            textarea.style.height = `${scrollHeight + 50}px`;}
    
    
    
    }

    if (bookmarkedMcqs.hasOwnProperty(mcqUid)) {
        // Apply the bookmarked style and select the corresponding bookmark type button
        $('#bookmark-button').addClass('bookmarked');
        $('.action-btn1').removeClass('selected');
        $(`.action-btn1[data-type="${bookmarkedMcqs[mcqUid]}"]`).addClass('selected');
    } else {
        // Reset the bookmark button and type buttons if not bookmarked
        $('#bookmark-button').removeClass('bookmarked');
        $('.action-btn1').removeClass('selected');
    }



        const questionImage = document.getElementById('question-image');
        if (mcq.image) {
            questionImage.src = `${mcq.image}`;
            console.log(questionImage.src)
            questionImage.style.display = 'block'; // Show image
        } else {
            questionImage.src = '';
            questionImage.style.display = 'none'; // Hide image
        }
    
        const optionsList = document.querySelector('.options');
        optionsList.innerHTML = ''; // Clear existing options
    
        const options = [
            { value: 'A', text: mcq.option_1 },
            { value: 'B', text: mcq.option_2 },
            { value: 'C', text: mcq.option_3 },
            { value: 'D', text: mcq.option_4 }
        ];
    
        const userAnswer = selectedAnswers[index]; // User's selected option (A, B, C, or D)
        const correctAnswerText = mcq.correct_option; // Correct answer text
        // Find the correct option value from the text
        const correctOption = options.find(opt => opt.text === correctAnswerText)?.value;
    
        options.forEach(option => {
            const li = document.createElement('li');
            li.innerHTML = `
                <input type="radio" name="option" value="${option.value}" class="option-radio" ${isReviewMode ? 'disabled' : ''}> 
                ${option.text}
            `;
    
            // Apply event listener only if not in review mode
            if (!isReviewMode) {
                li.addEventListener('click', () => selectOption(li, index));
            }
    
            // Highlight the options during review mode
            if (isReviewMode) {
                if (userAnswer === option.value) {
                    console.log('user:',userAnswer);
                    console.log('opt_val:',option.value);
                    console.log('corr:',correctOption)
                    if (option.value === correctOption) {
                        li.classList.add('user-correct'); // User's correct choice
                    } else {
                        li.classList.add('user-incorrect'); // User's incorrect choice
                    }
                } else if (option.value === correctOption) {
                    li.classList.add('correct-answer'); // Correct answer
                }
            }
    
            optionsList.appendChild(li);
        });
    
        // Restore selected answer if any
        if (userAnswer) {
            const selectedOption = optionsList.querySelector(`input[value="${userAnswer}"]`);
            if (selectedOption) {
                selectedOption.checked = true;
                selectedOption.parentElement.classList.add('selected');
            }
        }
    
        // Display review status if marked
        const revbutn = document.getElementById("review-button");
        
        const saveButton = document.getElementById("save-button");
        const scorebtn = document.getElementById("score-button");
        
        
        // Display review status if marked
        const statusText = document.getElementById('status-text');
        statusText.innerText = reviewQuestions[index] ? "Question under review" : "";
        if (!isReviewMode) {
        if (reviewQuestions[index]) {
            revbutn.style.display = "none"; // Show the first element
            saveButton.style.display = "block"; // Show the second element
        } else {
            revbutn.style.display = "block"; // Show the first element
            saveButton.style.display = "none"; // Hide the second element
        }     
    }else{
        scorebtn.style.display = "block";
        revbutn.style.display = "none"; // Show the first element
            saveButton.style.display = "none";
    }
        // Update review status circle
        const reviewStatus = document.getElementById('review-status');
        if (reviewQuestions[index]) {
            reviewStatus.style.backgroundColor = 'yellow'; // Yellow for review
        } else if (userAnswer) {
            reviewStatus.style.backgroundColor = 'green'; // Green for saved
        } else {
            reviewStatus.style.backgroundColor = 'transparent'; // No color if not reviewed or saved
        }
    
        document.getElementById('current-question').innerText = index + 1;
    
        // Hide 'Next' and show 'Submit' if on the last question and not in review mode
        if (index === mcqs.length - 1) {
            document.getElementById('next-button').style.display = 'none';
            document.getElementById('submit-button').style.display = !isReviewMode ? 'inline-block' : 'none';
        } else {
            document.getElementById('next-button').style.display = 'inline-block';
            document.getElementById('submit-button').style.display = isReviewMode ? 'none' : 'inline-block';
        }
        if(index==0){
            document.getElementById('back-button').style.display = 'none';
        }
        else{
            document.getElementById('back-button').style.display = 'inline-block';
        }
        
        updateNav();
        if (!isReviewMode) {
            const mcquid = mcq.uid;
            if (currentQuestionUID) {
                calculateTimeSpent(currentQuestionUID);
            }
            
            // Set the current question UID and start time
            currentQuestionUID = mcquid;
            currentQuestionStartTime = Date.now();
            currentquestionuidforoption =currentQuestionStartTime;
    }
    }
    



    function calculateTimeSpent(uid) {
        
        if (!currentQuestionStartTime) return; // If no start time, return
        console.log("curremt",currentQuestionStartTime);
        const endTime = Date.now();
        console.log("end",endTime);

        const timeSpent = (endTime - currentQuestionStartTime) / 1000; // Time in seconds
        
        // If this question already has some time tracked, add to it
        if (questionTimes[uid]) {
            questionTimes[uid] += timeSpent;
            console.log(questionTimes);
        } else {
            questionTimes[uid] = timeSpent;
        }
        console.log(questionTimes[uid]);
        var test_id = '{{ test_id }}';  // Pass the test_id to the function
        const timetaken = calculateTimeTaken();
        const csrftoken = getCookie('csrftoken');
            $.ajax({
                url: '/mcqs/save-answer/',
                type: 'POST',
                data: {
                    'test_id': test_id,
                    'mcq_uid': uid,
                    'time_spent': questionTimes[uid],
                    'time_taken':timetaken,
                },
                headers: {
                    'X-CSRFToken': csrftoken  // Include the CSRF token in the header
                },
                success: function (response) {
                    console.log('Answer and time saved successfully');
                },
                error: function (xhr, status, error) {
                    console.error('Error saving answer:', error);
                    console.log('Status:', status);
                    console.log('Response:', xhr.responseText);
                }
            });
        
}



    function selectOption(selectedLi, index) {
        const optionsList = document.querySelectorAll('.options li');
        const selectedInput = selectedLi.querySelector('input');
        
        const selectedValue = selectedInput.value;
        const selectedText = selectedLi.textContent.trim();
        // Check if the selected option is already checked
        const isAlreadySelected = selectedLi.classList.contains('selected');

        // Unselect all options
        optionsList.forEach(li => {
            li.classList.remove('selected'); // Remove 'selected' class from all options
            li.querySelector('input').checked = false; // Uncheck all options
        });
        
        if (!isAlreadySelected) {
            // Select the clicked option
            selectedLi.classList.add('selected');
            selectedInput.checked = true;
            selectedAnswers[index] = selectedValue;
            selectedAnswerTexts[index] = selectedText;
            var selected_option = selectedValue;
        } else {
            // Unselect the clicked option
            selectedAnswers[index] = null;
            selectedAnswerTexts[index] = null;
            var selected_option = '';
        }
        
        var mcq_uid = mcqs[index].uid
        var test_id = '{{ test_id }}';  // Pass the test_id to the function
          // Function to get the remaining time
       
        
        // Update the navigation button color based on the new selection state
        updateNavButtonColor(index, selectedAnswers[index] ? 'green' : reviewQuestions[index] ? 'yellow' : 'white');
        
        // Update the review status circle
        updateReviewStatusCircle();
        if (!isReviewMode) {
            const mcquid = mcqs[index].uid;
            if (currentQuestionUID) {
                uid = currentQuestionUID
                if (!currentquestionuidforoption) return; // If no start time, return
                const endTime = Date.now();
                console.log("cuurent",currentquestionuidforoption);
                console.log("end",endTime)
                const timeSpent = (endTime - currentquestionuidforoption) / 1000; // Time in seconds
                currentquestionuidforoption = Date.now();
                currentQuestionStartTime = currentquestionuidforoption;
                console.log(timeSpent);
            // If this question already has some time tracked, add to it
                if (questionTimes[uid]) {
                    questionTimes[uid] += timeSpent;
                } else {
                    questionTimes[uid] = timeSpent;
                }
                console.log(questionTimes[uid]);
            }
            
            // Set the current question UID and start time
           
    }      
        console.log("CHLA");
        const timetaken = calculateTimeTaken();

        const csrftoken = getCookie('csrftoken');
            $.ajax({
                url: '/mcqs/save-answer/',
                type: 'POST',
                data: {
                    'test_id': test_id,
                    'mcq_uid': mcq_uid,
                    'selected_option': selected_option,
                    'time_taken':timetaken,
                    'time_spent': questionTimes[uid],
                },
                headers: {
                    'X-CSRFToken': csrftoken  // Include the CSRF token in the header
                },
                success: function (response) {
                    console.log('Answer and time saved successfully');
                },
                error: function (xhr, status, error) {
                    console.error('Error saving answer:', error);
                    console.log('Status:', status);
                    console.log('Response:', xhr.responseText);
                }
            });
    }

    
    




    
    function markForReview() {
        const revbutn = document.getElementById("review-button");
        const saveButton = document.getElementById("save-button");

        if (!isReviewMode) {
        reviewQuestions[currentQuestionIndex] = true;
        console.log(reviewQuestions);
        document.getElementById('status-text').innerText = "Question under review";
        revbutn.style.display = "none";
        saveButton.style.display = "block";
        // Update the navigation button color to yellow
        updateNavButtonColor(currentQuestionIndex, 'yellow');

        // Update the review status circle
        updateReviewStatusCircle();
        }
        else{
            revbutn.style.display = "none";
        saveButton.style.display = "none";
        }
    }

    function saveAnswer() {
        const revbutn = document.getElementById("review-button");
        const saveButton = document.getElementById("save-button");

        if (!isReviewMode) {
            reviewQuestions[currentQuestionIndex] = false; // Remove review status
            document.getElementById('status-text').innerText = ""; // Clear review status text
            revbutn.style.display = "block";
            saveButton.style.display = "none";
            // Update the navigation button color to green
            updateNavButtonColor(currentQuestionIndex, 'green');
        

        // Update the review status circle
        updateReviewStatusCircle();
        }
        else{
            revbutn.style.display = "none";
            saveButton.style.display = "none";
        }
    }
    function updateReviewStatusCircle() {
        const reviewStatus = document.getElementById('review-status');
        if (reviewQuestions[currentQuestionIndex]) {
            reviewStatus.style.backgroundColor = 'yellow'; // Yellow for review
        } else if (selectedAnswers[currentQuestionIndex]) {
            reviewStatus.style.backgroundColor = 'green'; // Green for saved
        } else {
            reviewStatus.style.backgroundColor = 'transparent'; // No color if not reviewed or saved
        }
    }

    function updateNavButtonColor(index, color) {
        const nav = document.getElementById('question-nav');
        const buttons = nav.querySelectorAll('button');

        buttons.forEach(button => {
            if (parseInt(button.innerText) === index + 1) {
                button.style.backgroundColor = color;
            }
        });
    }

    function updateNav() {
        const nav = document.getElementById('question-nav');
        nav.innerHTML = '';
    
        const questionsPerPage = 10;
        const startQuestion = Math.floor(currentQuestionIndex / questionsPerPage) * questionsPerPage;
        const endQuestion = Math.min(startQuestion + questionsPerPage, mcqs.length);
    
        if (startQuestion > 0) {
            const backButton = document.createElement('button');
            backButton.innerText = 'Back';
            backButton.addEventListener('click', (event) => {
                currentQuestionIndex = startQuestion - 1; // Go back to the last question of the previous page
               
                updateNav(); // Update navigation after changing the currentQuestionIndex
                event.stopPropagation(); // Prevent click event from closing the navigation
            });
            nav.appendChild(backButton);
        }
    
        for (let i = startQuestion; i < endQuestion; i++) {
            const button = document.createElement('button');
            button.innerText = i + 1;
            button.addEventListener('click', (event) => {
                loadQuestion(i);
                currentQuestionIndex = i; // Set the currentQuestionIndex only when a question number is clicked
                updateNav(); // Update navigation to reflect the current active question
                event.stopPropagation(); // Prevent click event from closing the navigation
            });
            if (i === currentQuestionIndex) button.classList.add('active');
            if (isReviewMode) {
                if (selectedAnswerTexts[i] === mcqs[i].correct_option) {
                    button.style.backgroundColor = 'green'; // Correct answer
                } else if (selectedAnswerTexts[i]) {
                    button.style.backgroundColor = 'red'; // Wrong answer
                } else {
                    button.style.backgroundColor = 'transparent'; // Not attempted
                }
            } else{
            // Set the button color based on answer selection or review status
            if (selectedAnswers[i]) {
                button.style.backgroundColor = 'green';
            }
            if (reviewQuestions[i]) {
                button.style.backgroundColor = 'yellow';
            }
        }
            nav.appendChild(button);
        }
    
        if (endQuestion < mcqs.length) {
            const moreButton = document.createElement('button');
            moreButton.innerText = '...';
            moreButton.addEventListener('click', (event) => {
                currentQuestionIndex = endQuestion; // Move to the first question of the next set
                
                updateNav(); // Update navigation after changing the currentQuestionIndex
                event.stopPropagation(); // Prevent click event from closing the navigation
            });
            nav.appendChild(moreButton);
        }
    }

    $('.action-btn1').click(function() {
        const bookmarkType = $(this).data('type');
        const mcqUid = mcqs[current_que_index].uid;
        const testSessionId = '{{ test_id }}';  // Assuming test session ID is available in your context
        const csrftoken = getCookie('csrftoken');
        $("#loader").show();
        // AJAX request to save or update the bookmark
        $.ajax({
            url: '{% url "toggle_bookmark" %}',  // Your Django URL
            type: 'POST',
            data: {
                'mcq_uid': mcqUid,
                'bookmark_type': bookmarkType,
                'test_session_id': testSessionId,
                'csrfmiddlewaretoken': csrftoken
            },
            success: function(response) {
                if (response.status === 'bookmarked') {
                    // Add the question to the bookmarked list
                    bookmarkedMcqs[mcqUid] = bookmarkType;
                    console.log(bookmarkedMcqs)
                    // Update button colors for the selected bookmark type
                    $('.action-btn1').removeClass('selected');
                    $(`.action-btn1[data-type="${response.bookmark_type}"]`).addClass('selected');
                    $('#bookmark-button').addClass('bookmarked');
                } else if (response.status === 'unbookmarked') {
                    // Remove the question from the bookmarked list
                    delete bookmarkedMcqs[mcqUid];

                    // Reset button colors
                    $('.action-btn1').removeClass('selected');
                    $('#bookmark-button').removeClass('bookmarked');
                }
                $("#loader").hide();
            },
            error: function(xhr, status, error) {
                console.error('Error bookmarking:', error);
                $("#loader").hide();
            }
        });
    });


    function submitQuiz() {
        current_time =Date.now();
    const mcqIds = mcqs.map(mcq => mcq.uid);
    
    const mcq = mcqs[current_que_index];
    let userchoices ={};


    for (let index in mcqIds){
        if (selectedAnswerTexts.hasOwnProperty(index)){
            userchoices[mcqIds[index]] = selectedAnswerTexts[index];
        }else{
            userchoices[mcqIds[index]] = "";
        }
    }


    if (!isReviewMode) {
        const mcquid = mcq.uid;
        if (currentQuestionUID) {
            uid = currentQuestionUID
            if (!currentQuestionStartTime) return; // If no start time, return

            const endTime = current_time;
            const timeSpent = (endTime - currentQuestionStartTime) / 1000; // Time in seconds

        // If this question already has some time tracked, add to it
            if (questionTimes[uid]) {
                questionTimes[uid] += timeSpent;
            } else {
                questionTimes[uid] = timeSpent;
            }

        }
        console.log(questionTimes[uid]);
        // Set the current question UID and start time
       
}      
        const timetaken = calculateTimeTaken(); 
        const csrftoken = getCookie('csrftoken');
        const testId = '{{ test_id }}';
        $.ajax({
            url: '/mcqs/submitted_active/',
            type: 'POST',
            data: {
                'test_id': testId,
                'current_que_uid':uid,
                'timespent':questionTimes[uid],
                'userchoices':JSON.stringify(userchoices),
                'timetaken':timetaken,
            },
            headers: {
                'X-CSRFToken': csrftoken // Include the CSRF token in the header
            },
            success: function(response) {
                console.log('Test submitted successfully');
                
                // Now call the submit_quiz function after confirming test session submission
                submitQuizData();
            },
            error: function(xhr, status, error) {
                console.error('Error submitting test:', error);
                console.log('Status:', status);
                console.log('Response:', xhr.responseText);
            }
        });
        }
function submitQuizData() {
    const mcqIds = mcqs.map(mcq => mcq.uid);
    const csrftoken = getCookie('csrftoken');
    const testId = '{{ test_id }}'; // Assuming you have the test ID

    const body = mcqIds.map(uid => `mcq_ids=${encodeURIComponent(uid)}`).join('&') + `&test_id=${encodeURIComponent(testId)}`;

    // Fetch request to submit quiz data and calculate results
    fetch('/mcqs/submit_quiz/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRFToken': csrftoken
        },
        body: body
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(correctMcqs => {
        // Handle the correct answers and calculate results
        processQuizResults(correctMcqs);
    })
    .catch(error => {
        console.error('There was a problem with the fetch operation:', error);
    });
    console.log(selectedAnswerTexts);
}
function processQuizResults(correctMcqs) {
    const totalQuestions = mcqs.length;
    let correctAnswers = 0;
    let wrongAnswers = 0;
    let notAttempt = 0;

    correctMcqs.forEach(correctMcq => {
        const mcqIndex = mcqs.findIndex(mcq => mcq.uid === correctMcq.uid);
        if (mcqIndex !== -1) {
            mcqs[mcqIndex].correct_option = correctMcq.correct_option;
            mcqs[mcqIndex].explanation = correctMcq.explanation;
        }
    });

    mcqs.forEach((mcq, index) => {
        const selectedAnswer = selectedAnswerTexts[index];

        if (selectedAnswer === mcq.correct_option) {
            correctAnswers++;
        } else if (selectedAnswer !== undefined )  {
            wrongAnswers++;
        } else {
            notAttempt++;
        }
    });

    stopTimer();
    const timetaken = calculateTimeTaken();
    displayResults(totalQuestions, correctAnswers, wrongAnswers, notAttempt, timetaken);
}
function displayResults(totalQuestions, correctAnswers, wrongAnswers, notAttempt, timetaken) {
    document.getElementById("total-questions").innerText = totalQuestions;
    document.getElementById("correct-answers").innerText = correctAnswers;
    document.getElementById("wrong-answers").innerText = wrongAnswers;
    document.getElementById("time-taken").innerText = timetaken;
    document.getElementById("not-attempt").innerText = notAttempt;

    const totalBar = document.querySelector('.progress-bar.total');
    const correctBar = document.querySelector('.progress-bar.correct');
    const wrongBar = document.querySelector('.progress-bar.wrong');
    const notAttemptedBar = document.querySelector('.progress-bar.not-attempted');

    totalBar.style.width = '0';
    correctBar.style.width = '0';
    wrongBar.style.width = '0';
    notAttemptedBar.style.width = '0';

    setTimeout(() => {
        totalBar.style.width = '100%';
        correctBar.style.width = (correctAnswers / totalQuestions) * 100 + '%';
        wrongBar.style.width = (wrongAnswers / totalQuestions) * 100 + '%';
        notAttemptedBar.style.width = (notAttempt / totalQuestions) * 100 + '%';
    }, 100);

    document.getElementById("results-section").style.display = "block";
    document.querySelector('.mcq-container').style.display = 'none';
    document.querySelector('.back').style.display = 'inline-block';
}
    

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

document.getElementById('score-button').addEventListener('click', () => {
    document.getElementById("results-section").style.display = "block";
    document.querySelector('.mcq-container').style.display = 'none';
    document.querySelector('.back').style.display = 'inline-block';
});



    document.getElementById('next-button').addEventListener('click', () => {
        if (currentQuestionIndex < mcqs.length - 1) {
            currentQuestionIndex++;
            loadQuestion(currentQuestionIndex);
        }
    });
    
    document.getElementById('back-button').addEventListener('click', () => {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            loadQuestion(currentQuestionIndex);
        }
    });

    function showConfirmationModal() {
    const unansweredList = document.getElementById('unanswered-list');
    const reviewList = document.getElementById('review-list');
    unansweredList.innerHTML = '';
    reviewList.innerHTML = '';

    mcqs.forEach((mcq, index) => {
        if (!selectedAnswers[index]) {
            const li = document.createElement('li');
            li.innerText = `Question ${index + 1}`;
            unansweredList.appendChild(li);
        }
        if (reviewQuestions[index]) {
            const li = document.createElement('li');
            li.innerText = `Question ${index + 1}`;
            reviewList.appendChild(li);
        }
    });

    document.getElementById('confirmation-modal').style.display = 'flex';
}
// Select elements
const bookmarkBtn = document.getElementById('bookmark-button');
const expandedMenu = document.getElementById('expanded-menu');

// Toggle expanded menu visibility
bookmarkBtn.addEventListener('click', (event) => {
    event.stopPropagation();
    expandedMenu.classList.toggle('show');
    expandedMenu.classList.remove('hidden');
});

// Close menu when clicking outside
document.addEventListener('click', (event) => {
    if (!bookmarkBtn.contains(event.target) && !expandedMenu.contains(event.target)) {
        expandedMenu.classList.remove('show');
    }
});

// Close menu when clicking any of the action buttons
document.querySelectorAll('.action-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        expandedMenu.classList.remove('show');
    });
});

function hideConfirmationModal() {
    document.getElementById('confirmation-modal').style.display = 'none';
}

document.getElementById('submit-button').addEventListener('click', showConfirmationModal);

document.getElementById('modal-close').addEventListener('click', hideConfirmationModal);

document.getElementById('cancel-submit').addEventListener('click', hideConfirmationModal);

document.getElementById('confirm-submit').addEventListener('click', () => {
    submitQuiz(); // Call the existing submitQuiz function
    hideConfirmationModal();
});

    document.getElementById('review-button').addEventListener('click', markForReview);
    document.getElementById('save-button').addEventListener('click', saveAnswer);
    document.getElementById('menu-icon').addEventListener('click', () => {
        const nav = document.getElementById('question-nav');
        nav.style.display = nav.style.display === 'block' ? 'none' : 'block';
    });

    // Close the question navigation when clicking outside
    document.addEventListener('click', (event) => {
        if (!event.target.closest('#menu-icon') && !event.target.closest('#question-nav')) {
            document.getElementById('question-nav').style.display = 'none';
        }
    });
    document.getElementById('question-image').addEventListener('click', () => {
        document.getElementById('enlarged-image').src = document.getElementById('question-image').src;
        document.getElementById('image-viewer').style.display = 'flex';
    });

    document.getElementById('image-viewer').addEventListener('click', () => {
        document.getElementById('image-viewer').style.display = 'none';
    });
    {% if time_left_minutes %}
        let totalTime = Math.round({{ time_left_minutes }} * 60);
    {% else %}
        let totalTime =Math.round({{ total_time }} * 60);
    {% endif %}

    
    
    let timeLeft = totalTime; // Time in seconds (e.g., 10 minutes)
    let intervalId;
    function startTimer() {
        const timerElement = document.getElementById('timer');
        const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                timerElement.innerText = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        intervalId = setInterval(() => {
            if (timeLeft <= 0) {
                clearInterval(intervalId);
                submitQuiz(); // Automatically submit the quiz when time runs out
            } else {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                timerElement.innerText = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
            }
        }, 1000);
    }
    function stopTimer() {
    clearInterval(intervalId);
}
function calculateTimeTaken() {
    total_Time = Math.round({{ total_time }} * 60);
    const timeTaken = total_Time - timeLeft;
    const minutesTaken = Math.floor(timeTaken / 60);
    const secondsTaken = timeTaken % 60;
    return `${minutesTaken}:${secondsTaken < 10 ? '0' : ''}${secondsTaken}`;
}
document.getElementById('review-result-button').addEventListener('click', () => {
    showReviewMode();
});
function showReviewMode() {
    // Hide result section and show MCQ container
    isReviewMode = true; // Enter review mode
    document.getElementById('results-section').style.display = 'none'; // Hide results section
    document.querySelector('.mcq-container').style.display = 'block'; // Show MCQ container
    ensureScroll();
    const footer = document.querySelector('.header-buttons');
    
    footer.classList.add('review-mode');
    currentQuestionIndex = 0
        
    
    loadQuestion(currentQuestionIndex);
}

// Call startTimer when the page loads or the quiz starts
function ensureScroll() {
    const mcqContainer = document.querySelector('.mcq-container');
    const mcqContent = document.querySelector('.mcq-content');

    // Hide and show mcq-container to force reflow
    mcqContainer.style.display = 'none'; // Hide to force reflow
    mcqContainer.offsetHeight; // Trigger reflow
    mcqContainer.style.display = 'flex'; // Show again

    // Add a short delay to ensure repaint
    if (mcqContent) {
        // Ensure that mcq-content is scrollable
        mcqContent.style.overflowY = 'auto'; // Ensure overflow is enabled
        mcqContent.scrollTop = 0; // Optionally scroll to the top
    }
}
const canvas = document.getElementById('drawingCanvas');
const ctx = canvas.getContext('2d');
const toggleDrawBtn = document.getElementById('toggle-draw-btn');
let isDrawing = false;
let isDrawingModeActive = false;

// Set canvas dimensions
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

// Update canvas size when the window is resized
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Function to get the correct mouse/touch coordinates
function getCoordinates(e) {
    const rect = canvas.getBoundingClientRect();
    let x, y;

    if (e.touches && e.touches.length > 0) {
        // Touch event
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
    } else {
        // Mouse event
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
    }

    return { x, y }; // Adjusted coordinates
}

// Start drawing when mouse or touch starts
canvas.addEventListener('mousedown', (e) => {
    if (!isDrawingModeActive) return;
    isDrawing = true;
    const { x, y } = getCoordinates(e);
    ctx.beginPath();
    ctx.moveTo(x, y);
});

// Draw when mouse is moving or touch is moving
canvas.addEventListener('mousemove', (e) => {
    if (isDrawing && isDrawingModeActive) {
        const { x, y } = getCoordinates(e);
        ctx.lineTo(x, y);
        ctx.strokeStyle = 'black';  // Change this for different pen colors
        ctx.lineWidth = 2;  // Change this for pen thickness
        ctx.stroke();
    }
});

// Stop drawing when mouse is released or touch ends
canvas.addEventListener('mouseup', () => {
    isDrawing = false;
});

canvas.addEventListener('touchstart', (e) => {
    if (!isDrawingModeActive) return;
    e.preventDefault(); // Prevent scrolling
    isDrawing = true;
    const { x, y } = getCoordinates(e);
    ctx.beginPath();
    ctx.moveTo(x, y);
});

canvas.addEventListener('touchmove', (e) => {
    if (isDrawing && isDrawingModeActive) {
        const { x, y } = getCoordinates(e);
        ctx.lineTo(x, y);
        ctx.strokeStyle = 'black';  // Change this for different pen colors
        ctx.lineWidth = 2;  // Change this for pen thickness
        ctx.stroke();
    }
});

canvas.addEventListener('touchend', () => {
    isDrawing = false;
});
canvas.addEventListener('touchcancel', () => {
    isDrawing = false;
});

// Toggle drawing mode
toggleDrawBtn.addEventListener('click', () => {
    isDrawingModeActive = !isDrawingModeActive;

    if (isDrawingModeActive) {
        canvas.style.pointerEvents = 'auto';  // Enable interaction
        canvas.style.display = 'block';  // Show the canvas
        toggleDrawBtn.style.backgroundColor = 'red';
    } else {
        canvas.style.pointerEvents = 'none';  // Disable interaction
        canvas.style.display = 'none';  // Hide the canvas when deactivated
        toggleDrawBtn.style.backgroundColor = '#4CAF50';
    }
});

    loadQuestion(0);
    startTimer(); // Load the first question initially
</script>
<script>
let startX = 0;

    document.getElementById("mcq-container").addEventListener("touchstart", function(event) {
        startX = event.touches[0].clientX;
    });

    document.getElementById("mcq-container").addEventListener("touchend", function(event) {
        const endX = event.changedTouches[0].clientX;
        const diffX = startX - endX;
        const minSwipeDistance = window.innerWidth * 0.3;// Minimum swipe distance to detect a swipe

        if (Math.abs(diffX) > minSwipeDistance) {
            if (diffX > 0) {
                // Swipe left, trigger the next button's click event
                document.getElementById('next-button').click();
            } else {
                // Swipe right, trigger the back button's click event
                document.getElementById('back-button').click();
            }
        }
    });
</script>

{% endblock %}

{%block pp%}

<li class="dropdown">
    <a href="javascript:void(0)" class="dropbtn">
      
        <i class="fas fa-user-circle profile-icon"></i>
      
      {{ user.username }}
      
    </a>
    <div class="dropdown-content">
      <a href="#">Settings</a>
      <a href={% url 'logout' %}>Logout</a>
    </div>
  </li>


{%endblock%} 
{% block footer %}
    <!-- Leaving this block empty to remove the footer -->
{% endblock %}
